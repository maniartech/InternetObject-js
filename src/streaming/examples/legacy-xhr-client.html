<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legacy XHR Client Example</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #output { background: #f0f0f0; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; height: 300px; overflow-y: auto; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Legacy XHR Client Example</h1>
    <p>This example uses <code>XMLHttpRequest</code> and <code>createPushSource</code> to stream data from the server.</p>
    <div style="margin-bottom: 10px;">
        <button id="startBtn">Default Stream</button>
        <button id="batchBtn">Batch Stream</button>
        <button id="liveBtn">Live Stream</button>
        <button id="liveBatchBtn">Live Batch (5/s)</button>
        <button id="liveErrBtn">Live Stream (w/ Errors)</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>
    <div id="status">Ready</div>
    <pre id="output"></pre>

    <script type="module">
        import { openStream, createPushSource } from '/dist/index.js';

        const startBtn = document.getElementById('startBtn');
        const batchBtn = document.getElementById('batchBtn');
        const liveBtn = document.getElementById('liveBtn');
        const liveBatchBtn = document.getElementById('liveBatchBtn');
        const liveErrBtn = document.getElementById('liveErrBtn');
        const stopBtn = document.getElementById('stopBtn');
        const output = document.getElementById('output');
        const status = document.getElementById('status');

        let activeXhr = null;

        function log(msg) {
            output.textContent += msg + '\n';
            output.scrollTop = output.scrollHeight;
        }

        function setRunningState(running) {
            startBtn.disabled = running;
            batchBtn.disabled = running;
            liveBtn.disabled = running;
            liveBatchBtn.disabled = running;
            liveErrBtn.disabled = running;
            stopBtn.disabled = !running;
            if (running) {
                output.textContent = '';
                status.textContent = 'Streaming...';
            } else {
                activeXhr = null;
            }
        }

        startBtn.addEventListener('click', () => runStream('/stream'));
        batchBtn.addEventListener('click', () => runStream('/stream/batch'));
        liveBtn.addEventListener('click', () => runStream('/stream/live'));
        liveBatchBtn.addEventListener('click', () => runStream('/stream/live?batch=true'));
        liveErrBtn.addEventListener('click', () => runStream('/stream/live?error=true'));

        stopBtn.addEventListener('click', () => {
            if (activeXhr) {
                activeXhr.abort();
                log('Stream aborted by user');
                status.textContent = 'Aborted';
                setRunningState(false);
            }
        });

        async function runStream(url) {
            setRunningState(true);

            // 1. Create the bridge
            const { source, push, close } = createPushSource();

            // 2. Start the parser with the source
            const stream = openStream(source);

            // 3. Consume the stream (async loop)
            // We start this immediately so it's ready to receive data pushed from XHR
            const consumerPromise = (async () => {
                try {
                    for await (const item of stream) {
                        // Use a replacer to handle BigInts if present
                        const json = JSON.stringify(item.data, (key, value) =>
                            typeof value === 'bigint' ? value.toString() : value
                        );

                        let latency = '';
                        if (item.data && item.data.ts) {
                            const sent = new Date(item.data.ts);
                            const now = new Date();
                            latency = ` (Latency: ${now - sent}ms)`;
                        }

                        log(`Received: ${json} (Schema: ${item.schemaName})${latency}`);
                    }
                    log('Stream finished');
                    status.textContent = 'Finished';
                } catch (err) {
                    console.error('Stream error:', err);
                    log(`Stream error: ${err.message}`);
                    status.textContent = 'Error';
                } finally {
                    setRunningState(false);
                }
            })();

            // 4. Drive the source with XHR events
            const xhr = new XMLHttpRequest();
            activeXhr = xhr;
            xhr.open('GET', url);

            // Track how much data we've processed
            let seenBytes = 0;

            xhr.onprogress = () => {
                // Extract only the new part of the response
                const newData = xhr.responseText.substring(seenBytes);
                seenBytes = xhr.responseText.length;

                if (newData) {
                    console.log(`XHR Progress: ${newData.length} bytes. Total: ${seenBytes}. First 20 chars: ${newData.substring(0, 20).replace(/\n/g, '\\n')}`);
                    // LINK: Push the new data into the stream source
                    push(newData);
                } else {
                    console.log('XHR Progress fired but no new data');
                }
            };

            xhr.onload = () => {
                close(); // Signal stream completion
            };

            xhr.onerror = () => {
                close(new Error('Network Error')); // Signal error
            };

            xhr.onabort = () => {
                close(new Error('Aborted'));
            };

            xhr.send();

            await consumerPromise;
        }
    </script>
</body>
</html>
